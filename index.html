<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Countryball Elimination Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background: #eee; }
    .github-badge {
      position: fixed;
      bottom: 10px;
      right: 10px;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<a href="https://github.com/your-username/your-repo" class="github-badge">
  <img src="https://img.shields.io/badge/GitHub-Repo-black?logo=github" alt="GitHub Repo">
</a>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const FRICTION = 0.4;
const BOUNCINESS = 0.6;
const GRAVITY = 0.5;

const greenLineY = canvas.height - 50;
let greenLineColor = "green";

const colors = ["red", "blue", "green", "yellow", "purple", "orange", "pink", "brown", "cyan", "magenta"];
const balls = [];
const savedBalls = [];

for (let i = 0; i < 10; i++) {
  balls.push({
    x: Math.random() * canvas.width,
    y: Math.random() * 100,
    vx: (Math.random() - 0.5) * 5,
    vy: 0,
    radius: 15,
    color: colors[i],
    saved: false
  });
}

const obstacles = [];
for (let i = 0; i < 4; i++) {
  obstacles.push({
    x: 100 + i * 150,
    y: 200 + i * 50,
    width: 100,
    height: 10,
    angle: 0,
    speedX: (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1),
    speedY: (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1),
    rotationSpeed: Math.random() * 2
  });
}

let transitionX = 0;
let transitioning = false;

function startTransition() {
  transitioning = true;
}

function updatePhysics(ball) {
  if (ball.saved) return;

  ball.vy += GRAVITY;
  ball.x += ball.vx;
  ball.y += ball.vy;

  // Check collision with green line
  if (ball.y + ball.radius >= greenLineY) {
    ball.y = greenLineY - ball.radius;
    ball.vy *= -BOUNCINESS;
    ball.vx *= FRICTION;

    ball.saved = true;
    savedBalls.push(ball);

    if (savedBalls.length >= 9) {
      greenLineColor = "red";
      setTimeout(() => startTransition(), 2000);
    }
  }
}

function updateObstacles() {
  obstacles.forEach(obs => {
    obs.x += Math.sin(Date.now() * 0.001) * obs.speedX;
    obs.y += Math.cos(Date.now() * 0.001) * obs.speedY;
    obs.angle += obs.rotationSpeed * 0.01;
  });
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (transitioning) {
    transitionX -= 10;
    if (transitionX <= -canvas.width) {
      transitioning = false;
      transitionX = 0;
      // Reset game or go to next phase here
      alert('Next phase starts!');
    }
  }

  ctx.save();
  ctx.translate(transitionX, 0);

  // Green/red line
  ctx.fillStyle = greenLineColor;
  ctx.fillRect(0, greenLineY, canvas.width, 5);

  // Obstacles
  updateObstacles();
  obstacles.forEach(obs => {
    ctx.save();
    ctx.translate(obs.x, obs.y);
    ctx.rotate(obs.angle);
    ctx.fillStyle = "blue";
    ctx.fillRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height);
    ctx.restore();
  });

  // Balls
  balls.forEach(ball => {
    updatePhysics(ball);

    ctx.fillStyle = ball.color;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
  });

  // Show losing ball in center
  if (savedBalls.length === 9) {
    let loser = balls.find(b => !b.saved);
    if (loser) {
      loser.radius = 50;
      loser.x = canvas.width / 2;
      loser.y = canvas.height / 2;

      ctx.fillStyle = loser.color;
      ctx.beginPath();
      ctx.arc(loser.x, loser.y, loser.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();

  requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
